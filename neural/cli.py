#!/usr/bin/env python
import os
import sys
import subprocess
import click
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

try:
    tree = parser_instance.parse(content)
except Exception as e:
    logger.error(f"Error parsing {file}: {e}")
    sys.exit(1)

# Add the parent directory to the Python path
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))


from neural.parser.parser import create_parser, ModelTransformer
from neural.code_generation.code_generator import generate_code


@click.group()
def cli():
    """Neural CLI: A compiler-like interface for .neural and .nr files."""
    pass

@cli.command()
@click.argument('file', type=click.Path(exists=True))
@click.option('--backend', default='tensorflow', help='Target backend: tensorflow or pytorch', type=click.Choice(['tensorflow', 'pytorch']))
def compile(file, backend):
    """
    Compile a .neural or .nr file into an executable Python script.
    
    Example:
        neural compile my_model.neural --backend pytorch
    """
    ext = os.path.splitext(file)[1].lower()
    # Choose the appropriate start rule based on extension
    if ext in ['.neural', '.nr']:
        parser_instance = create_parser('network')
    elif ext == '.rnr':
        parser_instance = create_parser('research')
    else:
        click.echo(f"Unsupported file type: {ext}")
        sys.exit(1)

    with open(file, 'r') as f:
        content = f.read()
    
    try:
        tree = parser_instance.parse(content)
    except Exception as e:
        click.echo(f"Error parsing {file}: {e}")
        sys.exit(1)

    transformer = ModelTransformer()
    try:
        model_data = transformer.transform(tree)
    except Exception as e:
        click.echo(f"Error transforming {file}: {e}")
        sys.exit(1)

    code = generate_code(model_data, backend)
    output_file = os.path.splitext(file)[0] + f"_{backend}.py"
    with open(output_file, 'w') as f:
        f.write(code)
    click.echo(f"Compiled {file} to {output_file} for backend {backend}")

@cli.command()
@click.argument('file', type=click.Path(exists=True))
def run(file):
    """
    Run an executable neural model.
    
    Example:
        neural run my_model_pytorch.py
    """
    # Here, we assume that the file is a Python file generated by the compile command.
    subprocess.run([sys.executable, file], check=True)


@cli.command()
@click.argument('file', type=click.Path(exists=True))
@click.option('--format', default='html', help='Output format: html or png')
def visualize(file, format):
    """
    Visualize network architecture and shape propagation.
    
    Example:
        neural visualize my_model.neural --format png
    """
    from neural.shape_propagation.shape_propagator import ShapePropagator
    from neural.parser.parser import create_parser
    from neural.dashboard.tensor_flow import create_animated_network

    # Parse input file
    ext = os.path.splitext(file)[1].lower()
    parser_instance = create_parser('network' if ext in ['.neural', '.nr'] else 'research')
    
    with open(file, 'r') as f:
        content = f.read()
    
    try:
        tree = parser_instance.parse(content)
        model_data = ModelTransformer().transform(tree)
    except Exception as e:
        click.echo(f"Error processing {file}: {e}")
        sys.exit(1)

    # Propagate shapes
    propagator = ShapePropagator()
    input_shape = model_data['input']['shape']  # Get from parsed model
    if not input_shape:
        click.echo("Error: Input shape not defined in model!")
        sys.exit(1) 
    shape_history = []

    for layer in model_data['layers']:
        input_shape = propagator.propagate(input_shape, layer, model_data['framework'])
        shape_history.append({
            "layer": layer['type'],
            "output_shape": input_shape
        })

    # Generate visualizations
    report = propagator.generate_report()
    
    # Save Graphviz diagram
    dot = report['dot_graph']
    dot.format = 'png' if format == 'png' else 'svg'
    dot.render('architecture', cleanup=True)
    
    # Save Plotly visualization
    fig = report['plotly_chart']
    fig.write_html('shape_propagation.html')
    
    # Generate tensor flow animation
    tf_fig = create_animated_network(shape_history)
    tf_fig.write_html('tensor_flow.html')

    click.echo(f"""
    Visualizations generated:
    - architecture.{format} (Network architecture)
    - shape_propagation.html (Parameter count chart)
    - tensor_flow.html (Data flow animation)
    """)

if __name__ == '__main__':
    cli()
